#################
# General
#################

# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$@"
}

# Change to the root directory of the current git repository
function cdr() {
    local root
    root="$(git rev-parse --show-toplevel)" || return 1

    cd "$root" || return 1

    if [ $# -gt 0 ]; then
        cd "$@"
    fi
}


#################
# Kubernetes
#################

function filter_kubectl_output() {
    local PATTERN=$1
    local COMMAND=$2

    if [ ! -z "$PATTERN" ]; then
        eval $COMMAND | grep -i "$PATTERN"
    else
        eval $COMMAND
    fi
}

# Set the current kubeconfig (uses fzf if no argument provided)
function kcs() {
    local config="$1"
    
    # If no argument provided, use fzf to select
    if [[ -z "$config" ]]; then
        config=$(find "$HOME/.kube" -maxdepth 1 -type f ! -name "cache" ! -name "*.lock" ! -name "http-cache*" | \
                 sed "s|$HOME/.kube/||" | \
                 fzf --prompt="Select kubeconfig: " --height=40% --reverse)
        
        # Exit if no selection made
        if [[ -z "$config" ]]; then
            echo "No kubeconfig selected"
            return 1
        fi
    fi
    
    # Ensure the kubeconfig exists
    if [[ ! -f "$HOME/.kube/$config" ]]; then
        echo "Kubeconfig $config does not exist"
        return 1
    fi

    export KUBECONFIG=$HOME/.kube/$config
    echo "Switched to kubeconfig: $config"
}

# Set all kubeconfigs
function kca() {
    export KUBECONFIG=$(find "$HOME/.kube" -path "$HOME/.kube/cache" -prune -o -type f -print | sed 's/$/:/' | tr -d '\n' | sed 's/:$//')
}

# Unset the current kubeconfig
function kcu() {
    unset KUBECONFIG
}

# Get all pods in all namespaces except kube-system, flux-system and metallb-system
function kpa() {
    local PATTERN=$1
    local COMMAND="kubectl get pods --all-namespaces --field-selector 'metadata.namespace!=kube-system,metadata.namespace!=flux-system,metadata.namespace!=metallb-system'"

    filter_kubectl_output "$PATTERN" "$COMMAND"
}

# Watch all pods in all namespaces except kube-system, flux-system and metallb-system
function kpaw() {
    watch -n 1 kubectl get pods --all-namespaces --field-selector 'metadata.namespace!=kube-system,metadata.namespace!=flux-system,metadata.namespace!=metallb-system'
}

# Get cumulative CPU and Memory usage of all pods in a namespace (uses fzf if no argument provided)
function ktns() {
    local namespace="$1"
    local awk_script='{cpu+=$2; memory+=$3} END {print "CPU(m):", cpu, " - ", "Memory(Mi):", memory}'

    # If no argument provided, use fzf to select namespace
    if [[ -z "$namespace" ]]; then
        namespace=$(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}' | \
                   tr ' ' '\n' | \
                   fzf --prompt="Select namespace: " --height=40% --reverse)
        
        # If no selection, use current namespace context
        if [[ -z "$namespace" ]]; then
            echo "Using current namespace context"
            kubectl top pod --no-headers | awk "$awk_script"
            return
        fi
    fi
    
    echo "Namespace: $namespace"
    kubectl top pod --namespace "$namespace" --no-headers | awk "$awk_script"
}

# Get CPU and Memory usage of each namespace
function ktnsa() {
    kubectl get namespaces -o json | jq -r '.items[] | .metadata.name' | while read -r NAMESPACE; do
        echo "Namespace: $NAMESPACE"
        ktns "$NAMESPACE"
        echo
    done
}

# Set namespace for current context (uses fzf if no argument provided)
function kn() {
    local namespace="$1"
    
    # If no argument provided, use fzf to select
    if [[ -z "$namespace" ]]; then
        namespace=$(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}' | \
                   tr ' ' '\n' | \
                   fzf --prompt="Select namespace: " --height=40% --reverse)
        
        # Exit if no selection made
        if [[ -z "$namespace" ]]; then
            echo "No namespace selected"
            return 1
        fi
    fi
    
    kubectl config set-context --current --namespace="$namespace"
    echo "Switched to namespace: $namespace"
}

# Switch kubectl context (uses fzf if no argument provided)
function kc() {
    local context="$1"
    
    # If no argument provided, use fzf to select
    if [[ -z "$context" ]]; then
        context=$(kubectl config get-contexts -o name | \
                 fzf --prompt="Select context: " --height=40% --reverse)
        
        # Exit if no selection made
        if [[ -z "$context" ]]; then
            echo "No context selected"
            return 1
        fi
    fi
    
    kubectl config use-context "$context"
}

# Get logs from a pod (uses fzf to select pod and container if needed)
function kl() {
    local namespace="${1}"
    local pod_name
    local container_name
    
    # If namespace provided, use it; otherwise use current context namespace
    local ns_flag=""
    if [[ -n "$namespace" ]]; then
        ns_flag="-n $namespace"
    fi
    
    # Select pod with fzf
    pod_name=$(kubectl get pods $ns_flag -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | \
              fzf --prompt="Select pod: " --height=40% --reverse)
    
    if [[ -z "$pod_name" ]]; then
        echo "No pod selected"
        return 1
    fi
    
    # Check if pod has multiple containers
    local container_count
    container_count=$(kubectl get pod "$pod_name" $ns_flag -o jsonpath='{.spec.containers[*].name}' | wc -w | tr -d ' ')
    
    if [[ "$container_count" -gt 1 ]]; then
        # Multiple containers, let user select
        container_name=$(kubectl get pod "$pod_name" $ns_flag -o jsonpath='{.spec.containers[*].name}' | \
                        tr ' ' '\n' | \
                        fzf --prompt="Select container: " --height=40% --reverse)
        
        if [[ -z "$container_name" ]]; then
            echo "No container selected"
            return 1
        fi
        
        kubectl logs "$pod_name" $ns_flag -c "$container_name"
    else
        # Single container
        kubectl logs "$pod_name" $ns_flag
    fi
}

# Execute command in a pod (uses fzf to select pod and container if needed)
function ke() {
    local namespace="${1}"
    local pod_name
    local container_name
    
    # If namespace provided, use it; otherwise use current context namespace
    local ns_flag=""
    if [[ -n "$namespace" ]]; then
        ns_flag="-n $namespace"
    fi
    
    # Select pod with fzf
    pod_name=$(kubectl get pods $ns_flag -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | \
              fzf --prompt="Select pod: " --height=40% --reverse)
    
    if [[ -z "$pod_name" ]]; then
        echo "No pod selected"
        return 1
    fi
    
    # Check if pod has multiple containers
    local container_count
    container_count=$(kubectl get pod "$pod_name" $ns_flag -o jsonpath='{.spec.containers[*].name}' | wc -w | tr -d ' ')
    
    if [[ "$container_count" -gt 1 ]]; then
        # Multiple containers, let user select
        container_name=$(kubectl get pod "$pod_name" $ns_flag -o jsonpath='{.spec.containers[*].name}' | \
                        tr ' ' '\n' | \
                        fzf --prompt="Select container: " --height=40% --reverse)
        
        if [[ -z "$container_name" ]]; then
            echo "No container selected"
            return 1
        fi
        
        kubectl exec -it "$pod_name" $ns_flag -c "$container_name" -- /bin/sh
    else
        # Single container
        kubectl exec -it "$pod_name" $ns_flag -- /bin/sh
    fi
}

# Describe a pod (uses fzf to select pod)
function kdp() {
    local namespace="${1}"
    local pod_name
    
    # If namespace provided, use it; otherwise use current context namespace
    local ns_flag=""
    if [[ -n "$namespace" ]]; then
        ns_flag="-n $namespace"
    fi
    
    # Select pod with fzf
    pod_name=$(kubectl get pods $ns_flag -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | \
              fzf --prompt="Select pod: " --height=40% --reverse)
    
    if [[ -z "$pod_name" ]]; then
        echo "No pod selected"
        return 1
    fi
    
    kubectl describe pod "$pod_name" $ns_flag
}

# Delete a pod (uses fzf to select pod, requires confirmation)
function kdelp() {
    local namespace="${1}"
    local pod_name
    
    # If namespace provided, use it; otherwise use current context namespace
    local ns_flag=""
    if [[ -n "$namespace" ]]; then
        ns_flag="-n $namespace"
    fi
    
    # Select pod with fzf
    pod_name=$(kubectl get pods $ns_flag -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | \
              fzf --prompt="Select pod to DELETE: " --height=40% --reverse)
    
    if [[ -z "$pod_name" ]]; then
        echo "No pod selected"
        return 1
    fi
    
    # Confirmation prompt
    echo -n "Delete pod '$pod_name'? (y/n): "
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        kubectl delete pod "$pod_name" $ns_flag
    else
        echo "Cancelled"
    fi
}

# Describe a deployment (uses fzf to select deployment)
function kdd() {
    local namespace="${1}"
    local deployment_name
    
    # If namespace provided, use it; otherwise use current context namespace
    local ns_flag=""
    if [[ -n "$namespace" ]]; then
        ns_flag="-n $namespace"
    fi
    
    # Select deployment with fzf
    deployment_name=$(kubectl get deployments $ns_flag -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | \
                     fzf --prompt="Select deployment: " --height=40% --reverse)
    
    if [[ -z "$deployment_name" ]]; then
        echo "No deployment selected"
        return 1
    fi
    
    kubectl describe deployment "$deployment_name" $ns_flag
}

# Scale a deployment (uses fzf to select deployment)
function ks() {
    local namespace="${1}"
    local replicas="${2}"
    local deployment_name
    
    # If namespace provided, use it; otherwise use current context namespace
    local ns_flag=""
    if [[ -n "$namespace" ]] && [[ ! "$namespace" =~ ^[0-9]+$ ]]; then
        ns_flag="-n $namespace"
    else
        # First arg is likely replicas, not namespace
        replicas="$namespace"
        namespace=""
    fi
    
    # Select deployment with fzf
    deployment_name=$(kubectl get deployments $ns_flag -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | \
                     fzf --prompt="Select deployment: " --height=40% --reverse)
    
    if [[ -z "$deployment_name" ]]; then
        echo "No deployment selected"
        return 1
    fi
    
    # Prompt for replicas if not provided
    if [[ -z "$replicas" ]]; then
        echo -n "Number of replicas: "
        read -r replicas
    fi
    
    if [[ ! "$replicas" =~ ^[0-9]+$ ]]; then
        echo "Invalid replica count: $replicas"
        return 1
    fi
    
    kubectl scale deployment "$deployment_name" $ns_flag --replicas="$replicas"
}


#################
# Git
#################

# Git Clone and cd into it
function gc() {
    git clone "$1" && cd "$(basename "$1" .git)"
}

# Git Clone and cd into it and open in Cursor
function gcc() {
    gc "$1" && cursor .
}

# Git Clone and cd into it and open in VS Code
function gcv() {
    gc "$1" && code .
}

# Git Status with short output
function gs() {
    git status -s
}

# gitignore.io command line function
function gi() {
    local gitignore_file
    local content
    local response
    local default_templates=("vim" "macos" "visualstudiocode")
    local user_templates=()
    local all_templates=()

    gitignore_file=".gitignore"

    # Check if .gitignore already exists
    if [ -f "$gitignore_file" ]; then
        echo "A .gitignore file already exists in the current directory"
        echo -n "Do you want to overwrite it? (y/n): "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            return 0
        fi
    fi

    # Parse user input - handle comma-separated arguments
    if [ -n "$*" ]; then
        # Split by comma and process each template
        local IFS=','
        for template in $*; do
            # Trim whitespace (pure shell method)
            template="${template#"${template%%[![:space:]]*}"}"
            template="${template%"${template##*[![:space:]]}"}"
            
            if [ -n "$template" ]; then
                template_lower=$(echo "$template" | tr '[:upper:]' '[:lower:]')
                
                # Check if this matches a default (case-insensitive)
                local is_default=false
                for default in "${default_templates[@]}"; do
                    default_lower=$(echo "$default" | tr '[:upper:]' '[:lower:]')
                    if [ "$template_lower" = "$default_lower" ]; then
                        is_default=true
                        break
                    fi
                done
                
                # Only add non-defaults to user_templates
                if [ "$is_default" = false ]; then
                    user_templates+=("$template")
                fi
            fi
        done
    fi

    # Build final template list: user templates + defaults
    all_templates=("${user_templates[@]}" "${default_templates[@]}")
    
    # Join with comma for API call
    local template_string
    IFS=','
    template_string="${all_templates[*]}"
    unset IFS

    # Fetch gitignore.io content
    content="$(curl -sL "https://www.toptal.com/developers/gitignore/api/$template_string")"
    
    # Check if the API call was successful
    if echo "$content" | grep -q "ERROR:"; then
        echo "Error: Invalid gitignore templates" >&2
        echo "$content" >&2
        return 1
    fi

    # Append common patterns from GitHub raw URL
    local common_patterns
    common_patterns="$(curl -sL https://raw.githubusercontent.com/christian-deleon/dotfiles/refs/heads/main/.gitignore.dotfiles 2>/dev/null)"
    if [ -n "$common_patterns" ]; then
        content="$content"$'\n\n'"$common_patterns"
    fi

    # Write to .gitignore file
    echo "$content" > "$gitignore_file"
    echo "Created/updated .gitignore in current directory"
}


# Git Clone Bare for worktrees (optimized for AI agents)
function gcbare() {
    if [[ -z "$1" ]]; then
        echo "Usage: gcbare <repo-url>"
        echo "   ex: gcbare git@github.com:user/repo.git"
        return 1
    fi

    local repo_url="$1"
    local repo_name="$(basename "$repo_url" .git)"
    local bare_dir="${repo_name}.git"

    # Clone as bare repository
    git clone --bare "$repo_url" "$bare_dir" || return 1
    
    # Configure remote to fetch all branches (bare repos need this)
    git -C "$bare_dir" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    
    # Fetch all branches to have latest refs
    git -C "$bare_dir" fetch origin

    echo "Bare repo ready at: $bare_dir"
    echo "Create worktrees with: cd $bare_dir && gaw <branch-name> [base-branch]"
}


# Create worktree from bare or normal repo
function gaw() {
    if [[ -z "$1" ]]; then
        echo "Usage: gaw <branch-name> [base-branch]"
        echo "   ex: gaw agent-042 main"
        return 1
    fi

    local branch="$1"
    local base_branch="${2:-main}"

    # Try to detect if we're inside a bare repo
    if git rev-parse --is-bare-repository 2>/dev/null | grep -q true; then
        local repo_name="$(basename "$PWD" .git)"
        local worktree_path="../${repo_name}-${branch}"
        
        echo "Creating worktree: $worktree_path @ $branch (from $base_branch)"
        git worktree add -b "$branch" "$worktree_path" "$base_branch"
        cd "$worktree_path" || return 1
    else
        # Normal repo fallback
        local repo_name="$(basename "$(git rev-parse --show-toplevel)")"
        local worktree_path="../${repo_name}-${branch}"
        
        git worktree add -b "$branch" "$worktree_path" "$base_branch" || return 1
        cd "$worktree_path" || return 1
    fi
}


# Remove current worktree + branch (only works from inside worktree)
function grw() {
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo "Not inside a git worktree!"
        return 1
    fi

    local cwd="$(pwd)"
    local wt_name="$(basename "$cwd")"
    local main_repo="${wt_name%-*}"
    local branch="${wt_name##*-}"

    # Safety checks
    if [[ "$main_repo" = "$wt_name" ]]; then
        echo "Directory name doesn't look like a worktree (no '-' found)"
        return 1
    fi

    # Check for work that remote doesn't have
    local has_uncommitted=false
    local has_unpushed=false
    local current_branch="$(git rev-parse --abbrev-ref HEAD)"

    # Check for uncommitted changes
    if [[ -n "$(git status --porcelain)" ]]; then
        has_uncommitted=true
        echo "Warning: Worktree has uncommitted changes on branch '$current_branch'"
    fi

    # Check for unpushed commits on current branch
    if git show-ref --verify --quiet "refs/remotes/origin/$current_branch" 2>/dev/null; then
        if [[ -n "$(git log --oneline origin/$current_branch..HEAD 2>/dev/null)" ]]; then
            has_unpushed=true
            echo "Warning: Branch '$current_branch' has commits not pushed to remote"
        fi
    else
        echo "Warning: Branch '$current_branch' does not exist on remote"
    fi

    if $has_uncommitted || $has_unpushed; then
        echo "Worktree contains changes that remote doesn't have!"
        echo -n "Continue anyway? (y/n): "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            return 1
        fi
    else
        if gum confirm "Really delete worktree + branch '$branch' ?"; then
        local bare_path="../$main_repo.git"
        
        if [[ -d "$bare_path" ]]; then
            cd "$bare_path" || return 1
            git worktree remove "$cwd" --force
            git branch -D "$branch"
            echo "✓ Worktree and branch removed"
        else
            echo "Bare repo not found at expected path: $bare_path"
            return 1
        fi
    else
        echo "Cancelled."
    fi
}

# Quick fetch
function gfb() {
    if git rev-parse --is-bare-repository 2>/dev/null | grep -q true; then
        git fetch --prune origin
        echo "Bare repo updated ✓"
    else
        git fetch --prune
    fi
}

# Create and fetch
function gawf() {
    gfb
    gaw "$@"
}


#################
# Starship
#################

# Toggle Kubernetes module
function sk() {
    starship toggle kubernetes
}


#################
# 1Password
#################

# Login to 1Password CLI
function opl() {
    eval $(op signin)
}


#################
# nix-shell
#################

# Enter a nix-shell with the given packages
function nixp() {
    nix-shell -p "$@"
}


#################
# kubectl-ai
#################

# kubectl-ai interactive mode
function kai() {
    # Set provider and model since config.yaml is not working
    kubectl-ai --llm-provider=grok --model=grok-3 "$@"
}

# kubectl-ai in quiet mode
function kaiq() {
    kubectl-ai --llm-provider=grok --model=grok-3 --quiet "$@"
}
