#################
# General
#################

# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$@"
}

# Change to the root directory of the current git repository
function cdr() {
    local root
    root="$(git rev-parse --show-toplevel)" || return 1

    cd "$root" || return 1

    if [ $# -gt 0 ]; then
        cd "$@"
    fi
}


#################
# Kubernetes
#################

function filter_kubectl_output() {
    local PATTERN=$1
    local COMMAND=$2

    if [ ! -z "$PATTERN" ]; then
        eval $COMMAND | grep -i "$PATTERN"
    else
        eval $COMMAND
    fi
}

# Set the current kubeconfig
function kcs() {
    # Ensure the kubeconfig exists
    if [ ! -f "$HOME/.kube/$1" ]; then
        echo "Kubeconfig $1 does not exist"
        return
    fi

    export KUBECONFIG=$HOME/.kube/$1
}

# Set all kubeconfigs
function kca() {
    export KUBECONFIG=$(find "$HOME/.kube" -path "$HOME/.kube/cache" -prune -o -type f -print | sed 's/$/:/' | tr -d '\n' | sed 's/:$//')
}

# Unset the current kubeconfig
function kcu() {
    unset KUBECONFIG
}

# Get all pods in all namespaces except kube-system, flux-system and metallb-system
function kpa() {
    local PATTERN=$1
    local COMMAND="kubectl get pods --all-namespaces --field-selector 'metadata.namespace!=kube-system,metadata.namespace!=flux-system,metadata.namespace!=metallb-system'"

    filter_kubectl_output "$PATTERN" "$COMMAND"
}

# Watch all pods in all namespaces except kube-system, flux-system and metallb-system
function kpaw() {
    watch -n 1 kubectl get pods --all-namespaces --field-selector 'metadata.namespace!=kube-system,metadata.namespace!=flux-system,metadata.namespace!=metallb-system'
}

# Get cumulative CPU and Memory usage of all pods in a namespace
function ktns() {
    local NAMESPACE=$1
    local AWK_SCRIPT='{cpu+=$2; memory+=$3} END {print "CPU(m):", cpu, " - ", "Memory(Mi):", memory}'

    if [ -z "$NAMESPACE" ]; then
        kubectl top pod --no-headers | awk "$AWK_SCRIPT"
    else
        kubectl top pod --namespace "$NAMESPACE" --no-headers | awk "$AWK_SCRIPT"
    fi
}

# Get CPU and Memory usage of each namespace
function ktnsa() {
    kubectl get namespaces -o json | jq -r '.items[] | .metadata.name' | while read -r NAMESPACE; do
        echo "Namespace: $NAMESPACE"
        ktns "$NAMESPACE"
        echo
    done
}


#################
# Git
#################

# Git Clone and cd into it
function gc() {
    git clone "$1" && cd "$(basename "$1" .git)"
}

# Git Clone and cd into it and open in Cursor
function gcc() {
    gc "$1" && cursor .
}

# Git Clone and cd into it and open in VS Code
function gcv() {
    gc "$1" && code .
}

# Git Status with short output
function gs() {
    git status -s
}

# gitignore.io command line function
function gi() {
    local git_root
    local gitignore_file
    local content
    local response
    local user_input
    local templates=()
    local template_list
    local default_templates=("vim" "macos" "visualstudiocode")
    local found_defaults=()

    # Get the git repository root
    git_root="$(git rev-parse --show-toplevel 2>/dev/null)"
    if [ -z "$git_root" ]; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi

    gitignore_file="$git_root/.gitignore"

    # Check if .gitignore already exists
    if [ -f "$gitignore_file" ]; then
        echo "A .gitignore file already exists at: $gitignore_file"
        echo -n "Do you want to overwrite it? (y/n): "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            return 0
        fi
    fi

    # Parse user input - handle comma-separated arguments
    user_input="$*"
    
    # Convert comma-separated string to array
    IFS=',' read -r -a user_templates <<< "$user_input"
    
    # Process user templates and check for defaults (case-insensitive)
    for template in "${user_templates[@]}"; do
        template=$(echo "$template" | xargs)  # Trim whitespace
        if [ -n "$template" ]; then
            template_lower=$(echo "$template" | tr '[:upper:]' '[:lower:]')
            local is_default=false
            
            # Check if this template is in the default_templates array
            for default_template in "${default_templates[@]}"; do
                default_lower=$(echo "$default_template" | tr '[:upper:]' '[:lower:]')
                if [ "$template_lower" = "$default_lower" ]; then
                    found_defaults+=("$default_template")
                    is_default=true
                    break
                fi
            done
            
            # Only add to templates if it's not a default
            if [ "$is_default" = false ]; then
                templates+=("$template")
            fi
        fi
    done
    
    # Join templates with comma for API call (only request non-default templates)
    IFS=','
    template_list="${templates[*]}"
    unset IFS

    # Fetch gitignore.io content (only for non-default templates)
    content=""
    if [ -n "$template_list" ]; then
        content="$(curl -sL "https://www.toptal.com/developers/gitignore/api/$template_list")"
        
        # Check if the API call was successful (not an error message)
        if echo "$content" | grep -q "ERROR:"; then
            echo "Error: Invalid gitignore templates" >&2
            echo "$content" >&2
            return 1
        fi
    fi
    
    # Always fetch default templates from gitignore.io
    IFS=','
    local default_list="${default_templates[*]}"
    unset IFS
    
    local default_content
    default_content="$(curl -sL "https://www.toptal.com/developers/gitignore/api/$default_list")"
    
    if echo "$default_content" | grep -q "ERROR:"; then
        echo "Error: Failed to fetch default templates" >&2
        echo "$default_content" >&2
        return 1
    fi
    
    # Append default templates
    if [ -n "$content" ]; then
        content="$content"$'\n\n'"$default_content"
    else
        content="$default_content"
    fi

    # Append common patterns from GitHub raw URL
    local common_patterns
    common_patterns="$(curl -sL https://raw.githubusercontent.com/christian-deleon/dotfiles/refs/heads/main/.gitignore.dotfiles 2>/dev/null)"
    if [ -n "$common_patterns" ]; then
        content="$content"$'\n\n'"$common_patterns"
    fi

    # Write to .gitignore file
    echo "$content" > "$gitignore_file"
    echo "Created/updated .gitignore at: $gitignore_file"
}


#################
# Starship
#################

# Toggle Kubernetes module
function sk() {
    starship toggle kubernetes
}


#################
# 1Password
#################

# Login to 1Password CLI
function opl() {
    eval $(op signin)
}


#################
# nix-shell
#################

# Enter a nix-shell with the given packages
function nixp() {
    nix-shell -p "$@"
}


#################
# kubectl-ai
#################

# kubectl-ai interactive mode
function kai() {
    # Set provider and model since config.yaml is not working
    kubectl-ai --llm-provider=grok --model=grok-3 "$@"
}

# kubectl-ai in quiet mode
function kaiq() {
    kubectl-ai --llm-provider=grok --model=grok-3 --quiet "$@"
}
